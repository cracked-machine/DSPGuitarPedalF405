/*
 * RtosTaskManager.cpp
 *
 *  Created on: Apr 14, 2021
 *      Author: chris
 */

#include "RtosTaskManager.hpp"
#include <iostream>

void ISRTaskCode( void * parm );

RtosTaskManager::RtosTaskManager()
{
	ISRTaskHandle = NULL;

}

EventMachine* RtosTaskManager::getEM()
{
	return em;
}

void RtosTaskManager::initEventMachine()
{
	em = new EventMachine();
}

void RtosTaskManager::initIsrTask()
{
	/* Create the task without using any dynamic memory allocation. */
	ISRTaskHandle = xTaskCreateStatic(
		ISRTaskCode,       /* Function that implements the task. */
		"NAME",          /* Text name for the task. */
		200,      /* Number of indexes in the ISRTaskStack array. */
		(void*) 1,    /* Parameter passed into the task. */
		tskIDLE_PRIORITY,/* Priority at which the task is created. */
		ISRTaskStack,          /* Array to use as the task's stack. */
		&ISRTaskBuffer );  /* Variable to hold the task's data structure. */

}

TaskHandle_t getIsrTask()
{
	return this->ISRTaskHandle;
}

QueueHandle_t getQueue()
{
	return this->xQueue;
}

/* Function that implements the task being created. */
void ISRTaskCode( void * parm )
{

	while(1)
	{
		uint16_t item = 0;
		std::cout << "ISRTaskCode waiting for queue item" << std::endl;

		if( xQueueReceive( taskman->getQueue(), &( item ), ( TickType_t ) 10 ) == pdPASS)
		{
			std::cout << "ISRTaskCode retrieved queue item" << std::endl;
			switch(item)
			{
				case EXTI_PR_PR13:
					//em->evFootswitchA();
					break;
				case EXTI_PR_PR14:
					//em->evFootswitchB();
					break;
			}

		}



	}
}

