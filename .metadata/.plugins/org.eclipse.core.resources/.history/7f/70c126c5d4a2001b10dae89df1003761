/*
 * IIRFilterFx2.cpp
 *
 *  Created on: Apr 18, 2021
 *      Author: chris
 */

#include <IIRFilterFx2.hpp>


IIRFilterFx2::IIRFilterFx2()
{
#ifndef ENABLE_CPPUTEST
	  arm_biquad_cascade_df1_init_f32 ( &left_iir_settings, 1, (float*)iir_coeffs.data(), (float*)iir_left_state.data());
	  arm_biquad_cascade_df1_init_f32 ( &right_iir_settings, 1, (float*)iir_coeffs.data(), (float*)iir_right_state.data());
#endif
}

#ifndef ENABLE_IIR_BYPASS
	void IIRFilterFx2::process_half_u16(	AudioBlockU16< AbstractFx::FULL_BLK_SIZE_U16 > *pRxBuf,
										AudioBlockU16< AbstractFx::FULL_BLK_SIZE_U16 > *pTxBuf)
	{
		if(pRxBuf == nullptr || pTxBuf == nullptr)
			error_handler();
/*
		AudioBlockU16< AbstractFx::HALF_BLK_SIZE_U16 > pRxBufTmp;
		AudioBlockU16< AbstractFx::HALF_BLK_SIZE_U16 > pTxBufTmp;
		// do something for first half samples here if needed
		for(size_t i = 0; i < HALF_BLK_SIZE_U16; i++ )
		{
			pRxBufTmp[i] = (*pRxBuf)[i];
			pTxBufTmp[i] = pRxBufTmp[i];
			(*pTxBuf)[i] = pTxBufTmp[i];
		}
*/
		AudioBlockF32< IIRFilterFx2::QTR_BLK_SIZE_F32 > pRxBufTmp;
		AudioBlockF32< IIRFilterFx2::QTR_BLK_SIZE_F32 > pTxBufTmp;

		// copy first half sample block from rx in buffer into float tmp rx buffer
		for(size_t i = 0; i < HALF_BLK_SIZE_U16; i++ )
			pRxBufTmp[i/2] = (float)(*pRxBuf)[i];
		// copy first half sample float block into tmp tx buffer
		for(size_t i = 0; i < HALF_BLK_SIZE_U16; i++ )
			pTxBufTmp[i/2] = pRxBufTmp[i];
		// copy first half sample block into uint16_t tx out buffer
		for(size_t i = 0; i < HALF_BLK_SIZE_U16; i++ )
			(*pTxBuf)[i] = (uint16_t)pTxBufTmp[i/2];

	}

	void IIRFilterFx2::process_full_u16(	AudioBlockU16< AbstractFx::FULL_BLK_SIZE_U16 > *pRxBuf,
										AudioBlockU16< AbstractFx::FULL_BLK_SIZE_U16 > *pTxBuf)
	{
		if(pRxBuf == nullptr || pTxBuf == nullptr)
			error_handler();

/*		AudioBlockU16< AbstractFx::HALF_BLK_SIZE_U16 > pRxBufTmp;
		AudioBlockU16< AbstractFx::HALF_BLK_SIZE_U16 > pTxBufTmp;
		// do something for second half samples here if needed
		for(size_t i = HALF_BLK_SIZE_U16; i < FULL_BLK_SIZE_U16; i++ )
		{
			pRxBufTmp[i-HALF_BLK_SIZE_U16] = (*pRxBuf)[i];
			pTxBufTmp[i-HALF_BLK_SIZE_U16] = pRxBufTmp[i-HALF_BLK_SIZE_U16];
			(*pTxBuf)[i] = pTxBufTmp[i-HALF_BLK_SIZE_U16];
		}
*/

		AudioBlockF32< IIRFilterFx2::QTR_BLK_SIZE_F32 > pRxBufTmp;
		AudioBlockF32< IIRFilterFx2::QTR_BLK_SIZE_F32 > pTxBufTmp;

		// copy second half sample block from rx in buffer into float tmp rx buffer
		for(size_t i = HALF_BLK_SIZE_U16; i < FULL_BLK_SIZE_U16; i++ )
			pRxBufTmp[i-HALF_BLK_SIZE_U16] = (float)(*pRxBuf)[i];

		// copy second half sample block into tmp tx buffer
		for(size_t i = HALF_BLK_SIZE_U16; i < FULL_BLK_SIZE_U16; i++ )
			pTxBufTmp[i-HALF_BLK_SIZE_U16] = pRxBufTmp[i-HALF_BLK_SIZE_U16];

		// copy first half sample float block into uint16_t tx out buffer
		for(size_t i = HALF_BLK_SIZE_U16; i < FULL_BLK_SIZE_U16; i++ )
			(*pTxBuf)[i] = (uint16_t)pTxBufTmp[i-HALF_BLK_SIZE_U16];

	}

	void IIRFilterFx2::process_all_u16(	AudioBlockU16< AbstractFx::FULL_BLK_SIZE_U16 > *pRxBuf,
										AudioBlockU16< AbstractFx::FULL_BLK_SIZE_U16 > *pTxBuf)
	{
		if(pRxBuf == nullptr || pTxBuf == nullptr)
			error_handler();



	}




#endif

