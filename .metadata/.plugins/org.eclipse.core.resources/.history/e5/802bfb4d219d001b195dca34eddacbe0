/*
 * AppMain.cpp
 *
 *  Created on: Apr 11, 2021
 *      Author: chris
 */

#include <app_main.hpp>

#include <pedal_io_test.hpp>
#include <arm_math.h>

#include <EventMachine.hpp>
#include <Debounce.hpp>

#include "main.h"
#include "stm32f4xx_hal.h"
#include "stm32f4xx_hal_tim.h"
#include "tim.h"

#include <SEGGER_RTT.h>

#include "FreeRTOS.h"
#include "task.h"

#include <FreeRTOS_UserTasks.hpp>

#include <iostream>

#define STACK_SIZE 200


#ifdef __cplusplus
	extern "C"
	{
#endif


    TaskHandle_t xHandle = NULL;
	StaticTask_t xTaskBuffer;
	StackType_t xStack[ STACK_SIZE ];


	// create instance of the debounce manager for HAL Timer (specifically TIM14)
	typedef DebounceManager<TIM_TypeDef> HALDebounceManager;
	HALDebounceManager debounceManagerTim14(TIM14, 100);

	// create state machine instance
	EventMachine em;

	void appmain()
	{
		std::cout << "hello\n";

		//HAL_NVIC_SetPriorityGrouping( NVIC_PRIORITYGROUP_4 );

		// EXTI init

		 HAL_NVIC_SetPriority(EXTI0_IRQn, 5, 0);
		 HAL_NVIC_EnableIRQ(EXTI0_IRQn);
		 HAL_NVIC_SetPriority(EXTI1_IRQn, 5, 0);
		 HAL_NVIC_EnableIRQ(EXTI1_IRQn);
		 HAL_NVIC_SetPriority(EXTI2_IRQn, 5, 0);
		 HAL_NVIC_EnableIRQ(EXTI2_IRQn);
		 HAL_NVIC_SetPriority(EXTI15_10_IRQn, 5, 0);
		 HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);


		// enable the rotary encoders
		HAL_TIM_Encoder_Start_IT(&htim3, TIM_CHANNEL_ALL);
		HAL_TIM_Encoder_Start_IT(&htim4, TIM_CHANNEL_ALL);

		debounceManagerTim14.start();

		run_sys_checks();

		/* Create the task without using any dynamic memory allocation. */
		xHandle = xTaskCreateStatic(
			vTaskCode,       /* Function that implements the task. */
			"NAME",          /* Text name for the task. */
			STACK_SIZE,      /* Number of indexes in the xStack array. */
			( void * ) 1,    /* Parameter passed into the task. */
			tskIDLE_PRIORITY,/* Priority at which the task is created. */
			xStack,          /* Array to use as the task's stack. */
			&xTaskBuffer );  /* Variable to hold the task's data structure. */


		vTaskStartScheduler();


		while(1)
		{

		}
	}


/*
	// callback for switches
	void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
	{
		if(debounceManagerTim14.check_debounce())
		{
			switch(GPIO_Pin)
			{
				case GPIO_PIN_13:
					em.evFootswitchA();
					BaseType_t checkIfYieldRequired;
					checkIfYieldRequired = xTaskResumeFromISR(xHandle);
					portYIELD_FROM_ISR(checkIfYieldRequired);

					break;
				case GPIO_PIN_14:
					em.evFootswitchB();
					break;
			}
		}
	}
*/

	void EXTI0_IRQHandler(void)
	{

		BaseType_t checkIfYieldRequired;
		checkIfYieldRequired = xTaskResumeFromISR(xHandle);
		portYIELD_FROM_ISR(checkIfYieldRequired);

		// clear the EXTI pending bit
		EXTI->PR &= ~((EXTI_PR_PR0_Pos));
	}

	void EXTI1_IRQHandler(void)
	{

		BaseType_t checkIfYieldRequired;
		checkIfYieldRequired = xTaskResumeFromISR(xHandle);
		portYIELD_FROM_ISR(checkIfYieldRequired);

		// clear the EXTI pending bit
		EXTI->PR &= ~((EXTI_PR_PR1_Pos));
	}

	void EXTI2_IRQHandler(void)
	{

		BaseType_t checkIfYieldRequired;
		checkIfYieldRequired = xTaskResumeFromISR(xHandle);
		portYIELD_FROM_ISR(checkIfYieldRequired);

		// clear the EXTI pending bit
		EXTI->PR &= ~((EXTI_PR_PR2_Pos));
	}

	void EXTI15_10_IRQHandler(void)
	{

		BaseType_t checkIfYieldRequired;
		checkIfYieldRequired = xTaskResumeFromISR(xHandle);
		portYIELD_FROM_ISR(checkIfYieldRequired);

		// clear the EXTI pending bit
		EXTI->PR &= ~(
//			(EXTI_PR_PR10_Pos)
//			| (EXTI_PR_PR11_Pos)
//			| (EXTI_PR_PR12_Pos)
			  (EXTI_PR_PR13_Pos)
			| (EXTI_PR_PR14_Pos)
//			| (EXTI_PR_PR15_Pos)
			);
	}

	//
	void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
	{

	}

#ifdef __cplusplus
	}
#endif

