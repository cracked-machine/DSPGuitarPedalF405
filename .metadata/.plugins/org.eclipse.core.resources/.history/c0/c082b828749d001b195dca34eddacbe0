/*
 * RtosTaskManager.cpp
 *
 *  Created on: Apr 14, 2021
 *      Author: chris
 */

#include <ISRTaskManager.hpp>
#include <iostream>


void ISRTaskCode( void * parm );

static StaticQueue_t xStaticQueue;



RtosTaskManager::RtosTaskManager()
{
	ISRTaskHandle = NULL;

}

EventMachine* RtosTaskManager::getEM()
{
	return em;
}

void RtosTaskManager::initEventMachine()
{
	em = new EventMachine();
}

void RtosTaskManager::initIsrTask()
{
	/* Create the task without using any dynamic memory allocation. */
	ISRTaskHandle = xTaskCreateStatic(
		ISRTaskCode,       /* Function that implements the task. */
		"NAME",          /* Text name for the task. */
		200,      /* Number of indexes in the ISRTaskStack array. */
		this,    /* Parameter passed into the task. */
		tskIDLE_PRIORITY,/* Priority at which the task is created. */
		ISRTaskStack,          /* Array to use as the task's stack. */
		&ISRTaskBuffer );  /* Variable to hold the task's data structure. */

}

void RtosTaskManager::initIsrQueue()
{
	/* Create a queue capable of containing 10 uint64_t values. */
	xQueue = xQueueCreateStatic( 1,
								 sizeof(uint16_t),
								 ucQueueStorageArea,
								 &xStaticQueue );
}

TaskHandle_t RtosTaskManager::getIsrTask()
{
	return this->ISRTaskHandle;
}

QueueHandle_t RtosTaskManager::getQueue()
{
	return this->xQueue;
}

void RtosTaskManager::xQueueSendFromISR_wrapper(uint16_t item)
{

	xQueueSendFromISR(xQueue, &item, NULL);
}

/* Function that implements the task being created. */
void ISRTaskCode( void * parm )
{
	RtosTaskManager *taskman = static_cast<RtosTaskManager*>(parm);
	while(1)
	{
		uint16_t item = 0;
		std::cout << "ISRTaskCode waiting for queue item" << std::endl;

		if( xQueueReceive( taskman->getQueue(), &( item ), ( TickType_t ) 10 ) == pdPASS)
		{
			std::cout << "ISRTaskCode retrieved queue item" << std::endl;
			switch(item)
			{
				case EXTI_PR_PR13:
					taskman->getEM()->evFootswitchA();
					break;
				case EXTI_PR_PR14:
					taskman->getEM()->evFootswitchB();
					break;
			}
		}
	}
}

