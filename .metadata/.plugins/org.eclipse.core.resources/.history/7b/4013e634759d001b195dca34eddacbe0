/*
 * ISRTaskManager.cpp
 *
 *  Created on: Apr 14, 2021
 *      Author: chris
 */

#include <ISRTaskManager.hpp>
#include <iostream>


void ISRTaskCode( void * parm );

static StaticQueue_t xStaticQueue;



ISRTaskManager::ISRTaskManager()
{
	ISRTaskHandle = NULL;

}

EventMachine* ISRTaskManager::getIsrEventMan()
{
	return ISREventMan;
}

void ISRTaskManager::initEventMachine()
{
	ISREventMan = new EventMachine();
}

void ISRTaskManager::initIsrTask()
{
	/* Create the task without using any dynamic memory allocation. */
	ISRTaskHandle = xTaskCreateStatic(
		ISRTaskCode,       /* Function that implements the task. */
		"NAME",          /* Text name for the task. */
		200,      /* Number of indexes in the ISRTaskStack array. */
		this,    /* Parameter passed into the task. */
		tskIDLE_PRIORITY,/* Priority at which the task is created. */
		ISRTaskStack,          /* Array to use as the task's stack. */
		&ISRTaskBuffer );  /* Variable to hold the task's data structure. */

}

void ISRTaskManager::initIsrQueue()
{
	/* Create a queue capable of containing 10 uint64_t values. */
	ISRQueue = ISRQueueCreateStatic( 1,
								 sizeof(uint16_t),
								 ISRQueueStorageArea,
								 &xStaticQueue );
}

TaskHandle_t ISRTaskManager::getIsrTask()
{
	return this->ISRTaskHandle;
}

QueueHandle_t ISRTaskManager::getQueue()
{
	return this->ISRQueue;
}

void ISRTaskManager::ISRQueueSendFromISR_wrapper(uint16_t item)
{

	ISRQueueSendFromISR(ISRQueue, &item, NULL);
}

/* Function that implements the task being created. */
void ISRTaskCode( void * parm )
{
	ISRTaskManager *taskman = static_cast<ISRTaskManager*>(parm);
	while(1)
	{
		uint16_t item = 0;
		std::cout << "ISRTaskCode waiting for queue item" << std::endl;

		if( ISRQueueReceive( taskman->getQueue(), &( item ), ( TickType_t ) 10 ) == pdPASS)
		{
			std::cout << "ISRTaskCode retrieved queue item" << std::endl;
			switch(item)
			{
				case EXTI_PR_PR13:
					taskman->getIsrEventMan()->evFootswitchA();
					break;
				case EXTI_PR_PR14:
					taskman->getIsrEventMan()->evFootswitchB();
					break;
			}
		}
	}
}

