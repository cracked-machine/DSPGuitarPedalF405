/*
 * FreeRTOS_Tasks.c
 *
 *  Created on: 14 Apr 2021
 *      Author: chris
 */
/*
#include <FreeRTOS_UserTasks.hpp>

// STL
#include <iostream>


// the state machine
//#include <EventMachine.hpp>

// create state machine instance
EventMachine *em;

// FreeRTOS
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
*/
//#include "app_main.hpp"

// static RTOS task
/*
#define STACK_SIZE 200
TaskHandle_t ISRTaskHandle = NULL;
StaticTask_t ISRTaskBuffer;
StackType_t ISRTaskStack[ STACK_SIZE ];

#define QUEUE_LENGTH    1
#define ITEM_SIZE       sizeof( uint16_t )
static StaticQueue_t xStaticQueue;
uint8_t ucQueueStorageArea[ QUEUE_LENGTH * ITEM_SIZE ];
QueueHandle_t ISRQueue;

*/


/*
EventMachine* getEM()
{
	return em;
}
*/
/*
void initEventMachine()
{
	em = new EventMachine();
}
*/
/*
void initRTOS()
{

	ISRTaskHandle = xTaskCreateStatic(
		ISRTaskCode,
		"NAME",
		STACK_SIZE,
		(void*) 1,
		tskIDLE_PRIORITY,
		ISRTaskStack,
		&ISRTaskBuffer );


	// Create a queue capable of containing 10 uint64_t values.
	ISRQueue = ISRQueueCreateStatic( QUEUE_LENGTH,
								 ITEM_SIZE,
								 ucQueueStorageArea,
								 &xStaticQueue );

	vTaskStartScheduler();
}
*/
/* Function that implements the task being created. */
/*
void ISRTaskCode( void * parm )
{

	while(1)
	{
		uint16_t item = 0;
		std::cout << "ISRTaskCode waiting for queue item" << std::endl;

		if( ISRQueueReceive( ISRQueue, &( item ), ( TickType_t ) 10 ) == pdPASS)
		{
			std::cout << "ISRTaskCode retrieved queue item" << std::endl;
			switch(item)
			{
				case EXTI_PR_PR13:
					em->evFootswitchA();
					break;
				case EXTI_PR_PR14:
					em->evFootswitchB();
					break;
			}

		}



	}
}
*/

// receives event data and resumes the task
/*
void extiResumeTask(uint16_t* _pin)
{
	thePin = _pin;
	BaseType_t checkIfYieldRequired;
	checkIfYieldRequired = xTaskResumeFromISR(ISRTaskHandle);
	portYIELD_FROM_ISR(checkIfYieldRequired);
}
*/
/*
void ISRQueueSendFromISR_wrapper(uint16_t item)
{

	ISRQueueSendFromISR(ISRQueue, &item, NULL);
}
*/

